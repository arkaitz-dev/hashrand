# Zero Knowledge Authentication System

HashRand implements a **true Zero Knowledge architecture** where the server operates with complete user privacy, never storing or processing personal identifying information.

## Authentication Flow

```
POST /api/login/                # Generate magic link (no email storage)
POST /api/login/magiclink/      # Validate magic link with Ed25519 signature and get JWT tokens
DELETE /api/login/              # Clear refresh token cookie (logout)
POST /api/refresh               # Refresh expired access tokens using HttpOnly cookies
```

> **âš ï¸ IMPORTANT CHANGE (v0.19.14+)**: The GET `/api/login/?magiclink=...` endpoint has been **REMOVED** for security reasons. All magic link validation now requires **POST** requests with **Ed25519 signature verification** for enhanced cryptographic security.

## Frontend Ed25519 Integration (v0.19.15+)

**COMPLETE SYSTEM INTEGRATION**: As of v0.19.15, the Ed25519 digital signature system is **fully integrated and operational** with frontend-backend cryptographic authentication, universal browser compatibility, and enterprise-grade security.

### Automatic Ed25519 Workflow

The frontend `api.requestMagicLink()` function now automatically:

1. **Generates Ed25519 Keypair**: Creates cryptographically secure keypair using Web Crypto API
2. **Signs Authentication Message**: Automatically signs `email + pub_key` combination
3. **Manages Secure Storage**: Stores keypairs in IndexedDB with non-extractable private keys
4. **Handles Cleanup**: Automatically clears keypairs on logout for security

### Frontend Implementation

```typescript
// Automatic Ed25519 integration - no manual crypto required
import { api } from '$lib/api';

// Frontend automatically handles all Ed25519 operations
const response = await api.requestMagicLink(
  'user@example.com',
  'http://localhost:5173',
  '/result?endpoint=mnemonic&words=12'
);
```

**Behind the scenes:**
1. `web/src/lib/ed25519.ts` generates Ed25519 keypair
2. Message `email + pub_key` is signed automatically
3. Request includes `pub_key` and `signature` fields
4. Backend verifies signature before creating magic link

### Security Features

- **ğŸ” Non-extractable Keys**: Private keys stored as non-extractable CryptoKey objects
- **ğŸ’¾ IndexedDB Storage**: Secure browser database for keypair persistence
- **ğŸ§¹ Automatic Cleanup**: Ed25519 keypairs cleared on logout
- **ğŸ”„ Hybrid Architecture**: Web Crypto API primary with @noble/curves fallback
- **ğŸ›¡ï¸ Zero Knowledge**: No personal data stored, only cryptographic keys

## Magic Link Generation with Ed25519 Digital Signatures

**POST /api/login/:**
```json
{
  "email": "user@example.com",
  "pub_key": "a1b2c3d4e5f6789012345678901234567890123456789012345678901234567890",
  "signature": "1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef",
  "ui_host": "http://localhost:5173",
  "next": "/result?endpoint=mnemonic&language=english&words=12",
  "email_lang": "es"
}
```

**Request Parameters:**
- `email` (required) - User email address for magic link delivery
- `pub_key` (required) - Ed25519 public key (64-character hex string, 32 bytes) - **Auto-generated by frontend**
- `signature` (required) - Ed25519 signature of `email + pub_key` message (128-character hex string, 64 bytes) - **Auto-generated by frontend**
- `ui_host` (required) - Frontend URL for magic link generation - **Auto-provided by frontend**
- `next` (optional) - URL path for post-authentication redirection (e.g., "/result?endpoint=mnemonic&words=12")
- `email_lang` (required) - Language code for email template (e.g., "es", "fr", "ar") - **Always matches user's current language selection**

**Ed25519 Signature Generation:**
```bash
# Message to sign: concatenate email + pub_key (+ next if present)
message = "user@example.com" + "a1b2c3d4e5f6...67890"

# Sign with Ed25519 private key
signature = ed25519_sign(private_key, message)
```

**Response:**
```json
{
  "message": "Magic link generated successfully. Check development logs for the link.",
  "dev_magic_link": "http://localhost:5173/?magiclink=Ax1wogC82pgTzrfDu8QZhr"
}
```

## Magic Link Validation

**POST /api/login/magiclink/** (v0.19.14+)

**Request Body:**
```json
{
  "magiclink": "6EUrV3544PDKVqGKygJ1...",
  "signature": "2cf3fb2a8d88bdb3339a..."
}
```

**Response:**
```json
{
  "access_token": "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9...",
  "token_type": "Bearer",
  "expires_in": 180,
  "user_id": "HpGAge9YJ7uMvw4QV5qDPk",
  "next": "/result?endpoint=mnemonic&language=english&words=12"
}
```

> **ğŸ” SECURITY NOTE**: The `signature` field must be an Ed25519 signature of the magic link token itself, created using the same Ed25519 private key that was used during magic link generation.

## JWT Dual Token System with 2/3 Time-Based Refresh Logic

- **Access Token**: 1 minute validity (development: testing), 20 minutes (production)
- **Refresh Token**: 4 minutes validity (development: testing), 240 minutes (production)
- **HttpOnly Cookie**: Refresh token stored securely with HttpOnly, Secure, SameSite=Strict

### Enterprise-Grade 2/3 Time-Based Token Management

HashRand implements intelligent token lifecycle management that optimizes security and user experience:

#### **Two-Phase Refresh Strategy:**

1. **First 1/3 of Refresh Token Lifetime (Conservative Phase)**
   - **Time Window**: 0 â†’ 80 seconds (for 4-minute refresh tokens)
   - **Behavior**: Only renews access token, preserves existing refresh token
   - **Rationale**: Minimizes token regeneration overhead while maintaining security

2. **Last 2/3 of Refresh Token Lifetime (Security Reset Phase)**
   - **Time Window**: 80+ seconds â†’ expiration (for 4-minute refresh tokens)
   - **Behavior**: Complete token pair reset (both access + refresh renewed)
   - **Rationale**: Proactive security hardening when approaching expiration

#### **Automatic Token Refresh Flow:**

```bash
# Phase 1: Conservative refresh (first 1/3 - keeps existing refresh token)
curl -X POST "http://localhost:3000/api/custom?length=8" \
  -H "Authorization: Bearer expired-access-token" \
  -H "Cookie: refresh_token=valid-refresh-token"
# Response: HTTP 200 + x-new-access-token header (no Set-Cookie)

# Phase 2: Security reset (last 2/3 - resets both tokens)
curl -X POST "http://localhost:3000/api/custom?length=8" \
  -H "Authorization: Bearer expired-access-token" \
  -H "Cookie: refresh_token=valid-but-aging-token"
# Response: HTTP 200 + x-new-access-token + Set-Cookie: refresh_token=new-token
```

#### **Dual Token Expiration Handling:**

When both access and refresh tokens expire simultaneously, the system provides comprehensive cleanup:

```bash
# Both tokens expired scenario
curl -X POST "http://localhost:3000/api/custom?length=8" \
  -H "Authorization: Bearer expired-access-token" \
  -H "Cookie: refresh_token=expired-refresh-token"
# Response: HTTP 401
# Body: {"error": "Both access and refresh tokens have expired. Please re-authenticate."}
# Headers: Set-Cookie: refresh_token=; Max-Age=0; HttpOnly; Secure; SameSite=Strict; Path=/
```

**Frontend Integration:**
- **Smart Detection**: `isDualTokenExpiry()` identifies dual expiration scenarios
- **Automatic Cleanup**: `handleDualTokenExpiry()` clears sessionStorage and triggers re-authentication
- **Seamless UX**: Users see clean authentication dialog without technical error messages

### Logout System

```bash
# Logout and clear refresh token cookie
curl -X DELETE "http://localhost:3000/api/login/"
# Response: {"message": "Logged out successfully"}
# Sets: Set-Cookie: refresh_token=; HttpOnly; Secure; SameSite=Strict; Max-Age=0; Path=/
```

## Zero Knowledge Features

### Complete Data Privacy
- **No Email Storage**: Server never stores or processes email addresses
- **Email Privacy**: Emails used only for magic link delivery, never stored
- **Audit Trail Privacy**: All logs use Base58 usernames, not personal data
- **Compliance Ready**: GDPR/CCPA compliant by design - no personal data to manage

### Cryptographic User Identity System

```
Email Input â†’ Blake2b Hash â†’ Blake2b-keyed â†’ Per-User Salt â†’ Argon2id â†’ Blake2b-variable â†’ 16-byte user_id
                               (hmac_key)     (unique salt)   (19456KB)                      â†“
                                                                                    Base58 Username Display (~22 chars)
```

**Key Properties:**
- **Deterministic**: Same email always generates same user_id for consistency
- **One-Way**: Cryptographically impossible to reverse user_id back to email
- **High Security**: Argon2id with 19456KB memory cost following OWASP 2024 standards
- **User-Friendly**: Base58 encoding provides readable usernames without confusing characters

### Magic Link Cryptographic Verification & Encryption

```
User_ID + Timestamp â†’ ChaCha8RNG[44] â†’ nonce[12] + secret_key[32] â†’ ChaCha20 Encrypt â†’ Base58 Token (32 bytes â†’ 44 chars)
Blake2b-keyed(raw_magic_link, hmac_key) â†’ Blake2b-variable[16] â†’ Database Hash Index
```

**Security Architecture:**
- **ChaCha20 Encryption**: 32-byte encrypted magic link data using ChaCha20 stream cipher
- **Blake2b-keyed Integrity**: Prevents modification and tampering of magic links
- **Database Validation**: Additional security layer through token presence verification
- **Time-Limited**: 5-minute expiration prevents replay attacks (development: 15 minutes)
- **One-Time Use**: Magic links consumed immediately after validation
- **Optimized Length**: 44-character Base58 tokens (reduced from previous 66-character implementation)
- **No Email Reference**: Magic tokens contain only cryptographic hashes, never emails

## Email Integration & Multilingual Support

### Production Email Delivery

The magic link authentication system includes **complete Mailtrap email integration** with enhanced text-plain internationalization:

```bash
# Email delivery via Mailtrap REST API
- **Endpoint**: https://sandbox.api.mailtrap.io/api/send/{inbox_id}
- **Authentication**: Bearer token authentication
- **Format**: HTML + plain text dual format with text-specific translations
- **Internationalization**: 13 languages with dedicated plain text optimization
- **Architecture**: Proper separation of HTML and text concerns
- **Confirmation**: HTTP 200/202 status validation with error handling
- **Fallback**: Console logging when email delivery fails (development mode)
```

### Comprehensive Multilingual Email Templates

Magic link emails are delivered in **13 languages** matching the web UI language selector:

**Supported Languages:**
- **ğŸ‡ªğŸ‡¸ Spanish** (`es`) - EspaÃ±ol con terminologÃ­a nativa profesional
- **ğŸ‡ºğŸ‡¸ English** (`en`) - Professional technical terminology (default)
- **ğŸ‡«ğŸ‡· French** (`fr`) - FranÃ§ais avec terminologie technique prÃ©cise
- **ğŸ‡©ğŸ‡ª German** (`de`) - Deutsch mit professioneller technischer Sprache
- **ğŸ‡µğŸ‡¹ Portuguese** (`pt`) - PortuguÃªs europeu com terminologia tÃ©cnica
- **ğŸ‡·ğŸ‡º Russian** (`ru`) - Ğ ÑƒÑÑĞºĞ¸Ğ¹ Ñ Ñ‚ĞµÑ…Ğ½Ğ¸Ñ‡ĞµÑĞºĞ¾Ğ¹ Ñ‚ĞµÑ€Ğ¼Ğ¸Ğ½Ğ¾Ğ»Ğ¾Ğ³Ğ¸ĞµĞ¹
- **ğŸ‡¨ğŸ‡³ Chinese** (`zh`) - ä¸­æ–‡ï¼ˆç®€ä½“ï¼‰æŠ€æœ¯æœ¯è¯­
- **ğŸ‡¯ğŸ‡µ Japanese** (`ja`) - æ—¥æœ¬èªã®æŠ€è¡“ç”¨èª
- **ğŸ‡¸ğŸ‡¦ Arabic** (`ar`) - Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© Ù…Ø¹ Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ù†Øµ Ù…Ù† Ø§Ù„ÙŠÙ…ÙŠÙ† Ø¥Ù„Ù‰ Ø§Ù„ÙŠØ³Ø§Ø±
- **ğŸ‡®ğŸ‡³ Hindi** (`hi`) - à¤¹à¤¿à¤¨à¥à¤¦à¥€ à¤¤à¤•à¤¨à¥€à¤•à¥€ à¤¶à¤¬à¥à¤¦à¤¾à¤µà¤²à¥€ à¤•à¥‡ à¤¸à¤¾à¤¥
- **ğŸ´ó ¥ó ³ó £ó ´ó ¿ Catalan** (`ca`) - CatalÃ  amb terminologia tÃ¨cnica precisa
- **ğŸ´ó ¥ó ³ó §ó ¡ó ¿ Galician** (`gl`) - Galego con terminoloxÃ­a tÃ©cnica
- **ğŸ´ó ¥ó ³ó °ó ¶ó ¿ Basque** (`eu`) - Euskera termino tekniko egokiekin

### Email Template Features
- **HTML + Plain Text**: Dual format with text-specific translations for optimal compatibility
- **Text-Specific Translation Keys**: Dedicated plain text versions optimized for text-only email clients
  - `text_intro`: "Use the link below" (vs HTML "Click the button below")
  - `text_access_label`: "Access Link to HashRand" (text-appropriate instructions)
  - `text_security_section`: Localized security headers ("âš ï¸ Security Information:")
- **RTL Support**: Arabic template includes `dir="rtl"` for proper right-to-left display
- **Professional Branding**: Consistent "HashRand" branding across all languages
- **Security Messaging**: Clear magic link expiration and security information in each language
- **Cultural Adaptation**: Native terminology and proper grammar for each language
- **Architectural Separation**: HTML concerns (buttons, styling) properly separated from plain text
- **Fallback System**: Automatic fallback to English for unsupported language codes

### Email Configuration
```env
# Required environment variables for email integration
SPIN_VARIABLE_MAILTRAP_API_TOKEN=your-mailtrap-api-token
SPIN_VARIABLE_MAILTRAP_INBOX_ID=your-inbox-id

# Optional email settings
SPIN_VARIABLE_FROM_EMAIL=noreply@hashrand.dev  # Default sender
```

## Usage Examples

```bash
# Ed25519 Magic Link Authentication Flow

# 1. Generate Ed25519 keypair (using Node.js helper)
pub_key=$(node ./scripts/generate_hash.js)
echo "Generated public key: $pub_key"

# 2. Create message to sign (email + pub_key)
email="user@example.com"
message="${email}${pub_key}"

# 3. Sign message with Ed25519 private key
signature=$(node ./scripts/sign_payload.js "$message")
echo "Generated signature: $signature"

# 4. Request magic link with Ed25519 authentication
curl -X POST "http://localhost:3000/api/login/" \
  -H "Content-Type: application/json" \
  -d "{\"email\":\"$email\",\"email_lang\":\"en\",\"pub_key\":\"$pub_key\",\"signature\":\"$signature\"}"

# 5. Sign magic link token and validate with POST endpoint
magic_token="Ax1wogC82pgTzrfDu8QZhr"  # From development log
magic_signature=$(node ./scripts/sign_payload.js "$magic_token")

curl -X POST "http://localhost:3000/api/login/magiclink/" \
  -H "Content-Type: application/json" \
  -d "{\"magiclink\":\"$magic_token\",\"signature\":\"$magic_signature\"}"

# Request magic link in Spanish with Ed25519
curl -X POST "http://localhost:3000/api/login/" \
  -H "Content-Type: application/json" \
  -d "{\"email\":\"usuario@ejemplo.com\",\"pub_key\":\"$pub_key\",\"signature\":\"$signature\",\"email_lang\":\"es\"}"

# Request magic link in Arabic (RTL support) with Ed25519
curl -X POST "http://localhost:3000/api/login/" \
  -H "Content-Type: application/json" \
  -d "{\"email\":\"user@example.com\",\"pub_key\":\"$pub_key\",\"signature\":\"$signature\",\"email_lang\":\"ar\"}"
```

### Ed25519 Signature Verification Process

The backend performs comprehensive signature verification:

1. **Parse Request**: Extract `email`, `pub_key`, and `signature` from request
2. **Validate Format**: Ensure pub_key (64 hex chars) and signature (128 hex chars) are valid
3. **Recreate Message**: Concatenate `email + pub_key` (+ `next` if present)
4. **Verify Signature**: Use Ed25519 algorithm to verify signature against public key
5. **Create Magic Link**: Only proceed if signature verification succeeds

## Zero Knowledge Architecture Benefits

### Scalability & Performance
- **Deterministic Lookups**: Same email always produces same user_id for O(1) user identification
- **No PII Indexes**: Database indexes only on cryptographic hashes, never personal data
- **Stateless Sessions**: JWT tokens eliminate need for server-side session storage
- **Horizontal Scaling**: Zero Knowledge architecture supports distributed deployments

### Development & Operations
- **Safe Logging**: All application logs use Base58 usernames, safe to store and analyze
- **Testing Friendly**: Short token durations (20s access, 2min refresh) enable rapid testing cycles
- **Debug Safety**: Development logs never contain personal information
- **Incident Response**: Security incidents don't expose user personal data

---

*For endpoint usage, see [API Endpoints](./endpoints.md)*  
*For cryptographic details, see [Cryptography Documentation](./cryptography.md)*