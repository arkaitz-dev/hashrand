<script lang="ts">
	import BackToMenuButton from '$lib/components/BackToMenuButton.svelte';
	import FlashMessages from '$lib/components/FlashMessages.svelte';
	import LanguageSelect from '$lib/components/LanguageSelect.svelte';
	import { _, currentLanguage } from '$lib/stores/i18n';
	import { api } from '$lib/api';
	import { flashMessagesStore } from '$lib/stores/flashMessages';
	import { checkSessionOrAutoLogout } from '$lib/session-expiry-manager';
	import { getUserEmail } from '$lib/session';
	import { onMount } from 'svelte';
	import type { CreateSharedSecretResponse } from '$lib/types';
	import { logger } from '$lib/utils/logger';
	import { page } from '$app/stores';
	import { decryptPageParams } from '$lib/crypto';
	import { authStore } from '$lib/stores/auth';
	import { goto } from '$app/navigation';
	import { setCachedOtp } from '$lib/utils/confirm-read-cache';
	import { encryptSecretForCreation } from '$lib/crypto';
	import { getServerX25519PubKey } from '$lib/session';
	import { base64ToBytes, bytesToBase64 } from '$lib/crypto/crypto-encoding';
	import { getKeyPair } from '$lib/ed25519';
	import { privateKeyBytesToHex } from '$lib/ed25519/ed25519-core';

	// Expires hours allowed values (for slider with discrete jumps)
	const expiresHoursValues = [1, 3, 6, 12, 24, 36, 48, 60, 72];

	// Form state
	let senderEmail = $state('');
	let receiverEmail = $state('');
	let receiverLanguage = $state($currentLanguage); // Default to current UI language
	let secretText = $state('');
	let expiresHoursIndex = $state(4); // Default to index 4 = 24 hours
	let expiresHours = $derived(expiresHoursValues[expiresHoursIndex]);
	let maxReads = $state(3);
	let requireOtp = $state(false);
	let sendCopyToSender = $state(false);

	// UI state
	let isCreating = $state(false);
	let isLoadingEmail = $state(true);
	let isGeneratingHash = $state(false); // Loading state for hash generation from encrypted params
	let isAutoGenerated = $state(false); // Flag to indicate if secretText was auto-generated (readonly)
	let createdSecret: CreateSharedSecretResponse | null = $state(null);

	// E2E encryption state
	let backendPublicKey: string | null = $state(null); // Backend's X25519 public key for ECDH

	// Load user email and handle encrypted params on mount
	onMount(async () => {
		logger.info('[Route] Shared Secret creation page loaded');

		// âš ï¸ PROJECT-SPECIFIC RESTRICTION (can be removed in other projects)
		// This route should ONLY be accessible via "Share" button from result page (with 'p' param)
		// If you want to allow direct access to the form in another project, remove this block
		const searchParams = $page.url.searchParams;
		if (!searchParams.has('p')) {
			logger.warn(
				'[SharedSecret] Direct access blocked - missing encrypted params, redirecting to home'
			);
			goto('/');
			return;
		}

		// Step 1: Check if we have encrypted parameters in URL
		const hasEncryptedParams = searchParams.has('p');

		if (hasEncryptedParams) {
			logger.info('[SharedSecret] Encrypted parameters detected, generating hash');
			isGeneratingHash = true;

			try {
				// Get crypto tokens for decryption
				const cipherToken = authStore.getCipherToken();
				const nonceToken = authStore.getNonceToken();
				const hmacKey = authStore.getHmacKey();

				if (cipherToken && nonceToken && hmacKey) {
					// Decrypt parameters
					const decryptedParams = await decryptPageParams(searchParams, {
						cipherToken,
						nonceToken,
						hmacKey
					});

					if (decryptedParams) {
						// Extract endpoint and parameters
						const endpoint = String(decryptedParams.endpoint || '');
						const seed = decryptedParams.seed ? String(decryptedParams.seed) : null;

						if (endpoint && seed) {
							// Helper function to build params from decrypted data
							const { intToAlphabet, isAlphabetInt, intToMnemonicLang, isMnemonicLangInt } =
								await import('$lib/types');

							// Build request parameters
							let response: import('$lib/types').CustomHashResponse;

							if (endpoint === 'custom' || endpoint === 'generate') {
								const customRequest: import('$lib/types').SeedGenerateRequest = {
									seed,
									endpoint
								};

								if (decryptedParams.length) customRequest.length = Number(decryptedParams.length);
								if (decryptedParams.alphabet !== undefined) {
									const alphabetValue = decryptedParams.alphabet;
									if (typeof alphabetValue === 'number' && isAlphabetInt(alphabetValue)) {
										customRequest.alphabet = intToAlphabet(alphabetValue);
									}
								}
								if (decryptedParams.prefix) customRequest.prefix = String(decryptedParams.prefix);
								if (decryptedParams.suffix) customRequest.suffix = String(decryptedParams.suffix);

								response = await api.generateWithSeed(customRequest);
							} else if (endpoint === 'password') {
								const passwordRequest: import('$lib/types').SeedPasswordRequest = {
									seed
								};

								if (decryptedParams.length) passwordRequest.length = Number(decryptedParams.length);
								if (decryptedParams.alphabet !== undefined) {
									const alphabetValue = decryptedParams.alphabet;
									if (typeof alphabetValue === 'number' && isAlphabetInt(alphabetValue)) {
										const alphabetStr = intToAlphabet(alphabetValue);
										passwordRequest.alphabet = alphabetStr as 'no-look-alike' | 'full-with-symbols';
									}
								}

								response = await api.generatePasswordWithSeed(passwordRequest);
							} else if (endpoint === 'api-key') {
								const apiKeyRequest: import('$lib/types').SeedApiKeyRequest = {
									seed
								};

								if (decryptedParams.length) apiKeyRequest.length = Number(decryptedParams.length);
								if (decryptedParams.alphabet !== undefined) {
									const alphabetValue = decryptedParams.alphabet;
									if (typeof alphabetValue === 'number' && isAlphabetInt(alphabetValue)) {
										const alphabetStr = intToAlphabet(alphabetValue);
										apiKeyRequest.alphabet = alphabetStr as 'no-look-alike' | 'full';
									}
								}

								response = await api.generateApiKeyWithSeed(apiKeyRequest);
							} else if (endpoint === 'mnemonic') {
								const mnemonicRequest: import('$lib/types').SeedMnemonicRequest = {
									seed
								};

								if (decryptedParams.language !== undefined) {
									const langValue = decryptedParams.language;
									if (typeof langValue === 'number' && isMnemonicLangInt(langValue)) {
										mnemonicRequest.language = intToMnemonicLang(langValue);
									}
								}
								if (decryptedParams.words)
									mnemonicRequest.words = Number(decryptedParams.words) as 12 | 24;

								response = await api.generateMnemonicWithSeed(mnemonicRequest);
							} else {
								throw new Error(`Unknown endpoint: ${endpoint}`);
							}

							// Pre-fill secretText with the generated hash
							secretText = response.hash;
							isAutoGenerated = true; // Mark as auto-generated (field will be readonly)
							logger.info('[SharedSecret] Hash generated and pre-filled successfully');
						} else {
							logger.warn('[SharedSecret] Missing endpoint or seed in decrypted params');
						}
					} else {
						logger.warn('[SharedSecret] Failed to decrypt parameters');
					}
				} else {
					logger.warn('[SharedSecret] Missing crypto tokens for decryption');
				}
			} catch (error) {
				logger.error('[SharedSecret] Error generating hash from encrypted params:', error);
				// Continue with normal form - user can still use it manually
			} finally {
				isGeneratingHash = false;
			}
		}

		// Step 2: Load user email (always do this)
		const email = await getUserEmail();
		if (email) {
			senderEmail = email;
		}
		isLoadingEmail = false;

		// Step 3: Get backend X25519 public key from session (stored during login/refresh)
		try {
			backendPublicKey = await getServerX25519PubKey();
			if (backendPublicKey) {
				logger.debug('[SharedSecret] Backend X25519 public key loaded from session');
			} else {
				logger.warn('[SharedSecret] Backend X25519 public key not found in session');
				flashMessagesStore.addMessage($_('sharedSecret.failedToFetchBackendKey'));
			}
		} catch (error) {
			logger.error('[SharedSecret] Failed to get backend public key from session:', error);
			flashMessagesStore.addMessage($_('sharedSecret.failedToFetchBackendKey'));
			// Continue anyway - error will be shown on submit
		}
	});

	// Validation
	let receiverEmailError = $derived(
		receiverEmail && !isValidEmail(receiverEmail)
			? $_('sharedSecret.emailInvalid')
			: receiverEmail && receiverEmail === senderEmail
				? $_('sharedSecret.emailSameAsSender')
				: ''
	);
	let secretTextError = $derived(
		secretText.length > 512
			? $_('sharedSecret.secretTooLong')
			: secretText.length === 0 && secretText !== ''
				? $_('sharedSecret.secretEmpty')
				: ''
	);
	let expiresError = $derived(
		expiresHours < 1 || expiresHours > 72 ? $_('sharedSecret.expiresInvalid') : ''
	);
	let readsError = $derived(maxReads < 1 || maxReads > 10 ? $_('sharedSecret.readsInvalid') : '');

	let formValid = $derived(
		senderEmail.length > 0 &&
			isValidEmail(senderEmail) &&
			receiverEmail.length > 0 &&
			isValidEmail(receiverEmail) &&
			receiverEmail !== senderEmail &&
			secretText.length > 0 &&
			secretText.length <= 512 &&
			expiresHours >= 1 &&
			expiresHours <= 72 &&
			maxReads >= 1 &&
			maxReads <= 10
	);

	function isValidEmail(email: string): boolean {
		return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
	}

	async function handleCreate(event: Event) {
		event.preventDefault();
		logger.info('[Form] Submitting shared secret creation form');

		if (!formValid) {
			flashMessagesStore.addMessage($_('common.formInvalid'));
			return;
		}

		// Check session expiration before creation
		// If expired, performs automatic logout (redirect + cleanup + flash)
		const sessionValid = await checkSessionOrAutoLogout();

		if (!sessionValid) {
			// Session expired, auto-logout already performed
			return;
		}

		// Extract ui_host (same logic as magic link)
		const { extractDomain } = await import('$lib/utils/domain-extractor');
		const ui_host = extractDomain();

		if (!ui_host) {
			flashMessagesStore.addMessage('UI host is required for URL generation');
			return;
		}

		// Check if backend public key is available
		if (!backendPublicKey) {
			flashMessagesStore.addMessage($_('sharedSecret.backendKeyNotAvailable'));
			return;
		}

		// Get sender's Ed25519 private key from IndexedDB
		const keyPair = await getKeyPair();
		if (!keyPair || !keyPair.privateKeyBytes) {
			flashMessagesStore.addMessage($_('sharedSecret.privateKeyNotAvailable'));
			return;
		}

		// Convert private key bytes to hex for encryption
		const senderPrivateKeyHex = privateKeyBytesToHex(keyPair.privateKeyBytes);

		isCreating = true;

		try {
			// E2E Encryption: Encrypt secret_text before sending to backend
			logger.debug('[SharedSecret] Encrypting secret with E2E encryption');
			const { encryptedSecret, encryptedKeyMaterial } = encryptSecretForCreation(
				secretText,
				senderPrivateKeyHex,
				backendPublicKey
			);

			// Convert to base64 for transmission
			const encryptedSecretBase64 = bytesToBase64(encryptedSecret);
			const encryptedKeyMaterialBase64 = bytesToBase64(encryptedKeyMaterial);
			logger.debug('[SharedSecret] Secret encrypted successfully');

			const response = await api.createSharedSecret({
				sender_email: senderEmail,
				receiver_email: receiverEmail,
				// secret_text: secretText, // REMOVED: Now using E2E encryption
				encrypted_secret: encryptedSecretBase64,
				encrypted_key_material: encryptedKeyMaterialBase64,
				expires_hours: expiresHours,
				max_reads: maxReads,
				require_otp: requireOtp,
				send_copy_to_sender: sendCopyToSender,
				receiver_language: receiverLanguage,
				sender_language: $currentLanguage,
				ui_host
			});

			// Extract sender hash from URL
			const senderHashMatch = response.url_sender.match(/shared=([^&]+)/);
			if (senderHashMatch) {
				const senderHash = senderHashMatch[1];

				// Cache OTP if exists (for reloads)
				if (response.otp) {
					try {
						await setCachedOtp(senderHash, response.otp);
						logger.info('[SharedSecret] Cached OTP for sender tracking view');
					} catch (error) {
						logger.error('[SharedSecret] Failed to cache OTP:', error);
						// Non-critical, continue anyway
					}
				}

				// Redirect to sender tracking view
				flashMessagesStore.addMessage($_('sharedSecret.secretCreated'));
				goto(`/shared-secret/${senderHash}`);
			} else {
				// Fallback: show success view (should not happen)
				logger.warn('[SharedSecret] Failed to extract sender hash from URL');
				createdSecret = response;
				flashMessagesStore.addMessage($_('sharedSecret.secretCreated'));
			}
		} catch {
			flashMessagesStore.addMessage($_('sharedSecret.creationError'));
		} finally {
			isCreating = false;
		}
	}

	async function copyToClipboard(text: string, type: 'url' | 'reference' | 'otp') {
		try {
			await navigator.clipboard.writeText(text);
			const message =
				type === 'url'
					? $_('sharedSecret.copyUrl')
					: type === 'reference'
						? $_('sharedSecret.copyReference')
						: $_('sharedSecret.copyOtp');
			flashMessagesStore.addMessage(`${message}: ${$_('common.copied')}`);
		} catch {
			flashMessagesStore.addMessage($_('common.failedToCopy'));
		}
	}

	function resetForm() {
		receiverEmail = '';
		secretText = '';
		expiresHoursIndex = 4; // Reset to index 4 = 24 hours
		maxReads = 3;
		requireOtp = false;
		sendCopyToSender = false;
		createdSecret = null;
	}

	onMount(() => {
		// Clear any previous state
		createdSecret = null;
	});
</script>

<svelte:head>
	<title>{$_('sharedSecret.title')} - {$_('menu.brandName')}</title>
	<meta name="description" content={$_('sharedSecret.description')} />
</svelte:head>

<div
	class="flex-1 bg-gradient-to-br from-blue-50 to-indigo-100 dark:from-gray-900 dark:to-gray-800"
>
	<div class="container mx-auto px-4 py-8">
		<div class="max-w-3xl mx-auto">
			<!-- Header -->
			<div class="text-center mb-8">
				<div
					class="inline-flex items-center justify-center w-16 h-16 bg-indigo-600 rounded-full mb-4"
				>
					<span class="text-2xl">ðŸ“¬</span>
				</div>
				<h1 class="text-3xl font-bold text-gray-900 dark:text-white mb-2">
					{$_('sharedSecret.title')}
				</h1>
				<p class="text-gray-600 dark:text-gray-300">
					{$_('sharedSecret.description')}
				</p>
			</div>

			<!-- Flash Messages -->
			<FlashMessages />

			{#if !createdSecret}
				<!-- Creation Form -->
				<div class="bg-white dark:bg-gray-800 rounded-lg shadow-lg p-6 mb-6">
					<form onsubmit={handleCreate}>
						<!-- Sender Email (Display Only) -->
						<div class="mb-4">
							<div class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
								{$_('sharedSecret.senderEmail')}
							</div>
							{#if isLoadingEmail}
								<p class="text-gray-500 dark:text-gray-400 italic">
									{$_('common.loading')}...
								</p>
							{:else if senderEmail}
								<p
									class="px-4 py-2 bg-gray-100 dark:bg-gray-700 rounded-lg text-gray-900 dark:text-white font-medium"
								>
									{senderEmail}
								</p>
							{:else}
								<p class="text-red-600 dark:text-red-400">
									{$_('sharedSecret.emailNotAvailable')}
								</p>
							{/if}
						</div>

						<!-- Receiver Email -->
						<div class="mb-4">
							<label
								for="receiver-email"
								class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2"
							>
								{$_('sharedSecret.receiverEmail')}
							</label>
							<input
								type="email"
								id="receiver-email"
								bind:value={receiverEmail}
								placeholder={$_('sharedSecret.receiverEmailPlaceholder')}
								class="w-full px-4 py-2 border border-gray-300 dark:border-gray-600 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-transparent dark:bg-gray-700 dark:text-white"
								required
							/>
							{#if receiverEmailError}
								<p class="mt-1 text-sm text-red-600 dark:text-red-400">{receiverEmailError}</p>
							{/if}
						</div>

						<!-- Receiver Language -->
						<div class="mb-4">
							<label
								for="receiver-language"
								class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2"
							>
								{$_('common.selectLanguage')} ({$_('sharedSecret.receiverEmail')})
							</label>
							<LanguageSelect id="receiver-language" bind:value={receiverLanguage} />
						</div>

						<!-- Secret Text -->
						<div class="mb-4">
							<label
								for="secret-text"
								class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2"
							>
								{$_('sharedSecret.secretText')}
								{#if isGeneratingHash}
									<span class="text-indigo-600 dark:text-indigo-400 text-xs ml-2">
										({$_('common.loading')}...)
									</span>
									<!-- {:else if isAutoGenerated}
									<span
										class="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-purple-100 text-purple-800 dark:bg-purple-900 dark:text-purple-200 ml-2"
									>
										ðŸ”— {$_('common.autoGenerated')}
									</span> -->
								{/if}
							</label>
							<textarea
								id="secret-text"
								bind:value={secretText}
								placeholder={isGeneratingHash
									? $_('common.loading') + '...'
									: $_('sharedSecret.secretTextPlaceholder')}
								rows="4"
								class="w-full px-4 py-2 border border-gray-300 dark:border-gray-600 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-transparent dark:bg-gray-700 dark:text-white resize-none {isGeneratingHash
									? 'opacity-60'
									: ''} {isAutoGenerated ? 'bg-gray-50 dark:bg-gray-800 cursor-not-allowed' : ''}"
								disabled={isGeneratingHash}
								readonly={isAutoGenerated}
								required
							></textarea>
							<!-- <div class="mt-1 text-sm text-gray-500 dark:text-gray-400 text-right">
								{secretText.length}/512
							</div> -->
							{#if secretTextError}
								<p class="mt-1 text-sm text-red-600 dark:text-red-400">{secretTextError}</p>
							{/if}
						</div>

						<!-- Expires Hours -->
						<div class="mb-4">
							<label
								for="expires-hours"
								class="flex justify-between items-center text-sm font-medium text-gray-700 dark:text-gray-300 mb-2"
							>
								<span>{$_('sharedSecret.expiresHours')}</span>
								<span class="text-indigo-600 dark:text-indigo-400 font-bold">{expiresHours}h</span>
							</label>
							<input
								type="range"
								id="expires-hours"
								bind:value={expiresHoursIndex}
								min="0"
								max="8"
								step="1"
								class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer dark:bg-gray-700 accent-indigo-600"
								required
							/>
							{#if expiresError}
								<p class="mt-1 text-sm text-red-600 dark:text-red-400">{expiresError}</p>
							{/if}
						</div>

						<!-- Max Reads -->
						<div class="mb-4">
							<label
								for="max-reads"
								class="flex justify-between items-center text-sm font-medium text-gray-700 dark:text-gray-300 mb-2"
							>
								<span>{$_('sharedSecret.maxReads')}</span>
								<span class="text-indigo-600 dark:text-indigo-400 font-bold">{maxReads}</span>
							</label>
							<input
								type="range"
								id="max-reads"
								bind:value={maxReads}
								min="1"
								max="10"
								step="1"
								class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer dark:bg-gray-700 accent-indigo-600"
								required
							/>
							{#if readsError}
								<p class="mt-1 text-sm text-red-600 dark:text-red-400">{readsError}</p>
							{/if}
						</div>

						<!-- Require OTP -->
						<div class="mb-4">
							<label class="flex items-center">
								<input
									type="checkbox"
									bind:checked={requireOtp}
									class="w-4 h-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500 dark:border-gray-600 dark:bg-gray-700"
								/>
								<span class="ml-2 text-sm text-gray-700 dark:text-gray-300">
									{$_('sharedSecret.requireOtp')}
								</span>
							</label>
						</div>

						<!-- Send Copy to Sender -->
						<div class="mb-6">
							<label class="flex items-center">
								<input
									type="checkbox"
									bind:checked={sendCopyToSender}
									class="w-4 h-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500 dark:border-gray-600 dark:bg-gray-700"
								/>
								<span class="ml-2 text-sm text-gray-700 dark:text-gray-300">
									{$_('sharedSecret.sendCopyToSender')}
								</span>
							</label>
						</div>

						<!-- Submit Button -->
						<button
							type="submit"
							disabled={!formValid || isCreating}
							class="w-full bg-indigo-600 hover:bg-indigo-700 disabled:bg-gray-400 disabled:cursor-not-allowed text-white font-semibold py-3 px-6 rounded-lg transition-colors duration-200"
						>
							{isCreating ? $_('sharedSecret.creating') : $_('sharedSecret.createSecret')}
						</button>
					</form>
				</div>
			{:else}
				<!-- Success Result -->
				<div class="bg-white dark:bg-gray-800 rounded-lg shadow-lg p-6 mb-6">
					<h2 class="text-2xl font-bold text-gray-900 dark:text-white mb-4">
						{$_('sharedSecret.secretCreated')}
					</h2>

					<!-- Sender URL -->
					<div class="mb-4">
						<label
							for="sender-url"
							class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2"
						>
							{$_('sharedSecret.yourUrl')}
						</label>
						<div class="flex gap-2">
							<input
								id="sender-url"
								type="text"
								readonly
								value={createdSecret.url_sender}
								class="flex-1 px-4 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-gray-50 dark:bg-gray-700 dark:text-white"
							/>
							<button
								onclick={() => copyToClipboard(createdSecret!.url_sender, 'url')}
								class="bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-2 px-4 rounded-lg transition-colors duration-200"
							>
								{$_('sharedSecret.copyUrl')}
							</button>
						</div>
					</div>

					<!-- Receiver URL -->
					<div class="mb-4">
						<label
							for="receiver-url"
							class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2"
						>
							{$_('sharedSecret.receiverUrl')}
						</label>
						<div class="flex gap-2">
							<input
								id="receiver-url"
								type="text"
								readonly
								value={createdSecret.url_receiver}
								class="flex-1 px-4 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-gray-50 dark:bg-gray-700 dark:text-white"
							/>
							<button
								onclick={() => copyToClipboard(createdSecret!.url_receiver, 'url')}
								class="bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-2 px-4 rounded-lg transition-colors duration-200"
							>
								{$_('sharedSecret.copyUrl')}
							</button>
						</div>
					</div>

					<!-- Reference Hash -->
					<div class="mb-4">
						<label
							for="reference-hash"
							class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2"
						>
							{$_('sharedSecret.reference')}
						</label>
						<div class="flex gap-2">
							<input
								id="reference-hash"
								type="text"
								readonly
								value={createdSecret.reference}
								class="flex-1 px-4 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-gray-50 dark:bg-gray-700 dark:text-white font-mono"
							/>
							<button
								onclick={() => copyToClipboard(createdSecret!.reference, 'reference')}
								class="bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-2 px-4 rounded-lg transition-colors duration-200"
							>
								{$_('sharedSecret.copyReference')}
							</button>
						</div>
					</div>

					<!-- OTP (if required) -->
					{#if createdSecret.otp}
						<div class="mb-6">
							<label
								for="otp-code"
								class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2"
							>
								{$_('sharedSecret.otpCode')}
							</label>
							<div class="flex gap-2">
								<input
									id="otp-code"
									type="text"
									readonly
									value={createdSecret.otp}
									class="flex-1 px-4 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-gray-50 dark:bg-gray-700 dark:text-white font-mono text-2xl text-center tracking-widest"
								/>
								<button
									onclick={() => copyToClipboard(createdSecret!.otp!, 'otp')}
									class="bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-2 px-4 rounded-lg transition-colors duration-200"
								>
									{$_('sharedSecret.copyOtp')}
								</button>
							</div>
						</div>
					{/if}

					<!-- New Secret Button -->
					<button
						onclick={resetForm}
						class="w-full bg-green-600 hover:bg-green-700 text-white font-semibold py-3 px-6 rounded-lg transition-colors duration-200"
					>
						{$_('sharedSecret.createSecret')}
					</button>
				</div>
			{/if}

			<!-- Back Button -->
			<BackToMenuButton />
		</div>
	</div>
</div>
