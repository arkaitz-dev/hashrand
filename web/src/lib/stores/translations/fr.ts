import type { I18nTexts } from '$lib/types';

export const fr: I18nTexts = {
	common: {
		back: 'Retour',
		generate: 'Générer',
		copy: 'Copier',
		copied: 'Copié !',
		backToMenu: 'Retour au Menu',
		loading: 'Génération...',
		error: "Une erreur s'est produite",
		result: 'Résultat',
		choose: 'Choisir',
		type: 'Type',
		length: 'Longueur',
		generated: 'Généré',
		format: 'Format',
		security: 'Sécurité',
		loadingVersion: 'Chargement de la version...',
		versionsUnavailable: 'Versions indisponibles',
		generationDetails: 'Détails de Génération',
		parametersUsed: 'Paramètres Utilisés',
		generateAnother: 'Générer un Autre',
		adjustSettings: 'Ajuster les Paramètres',
		navigateTo: 'Naviguer vers',
		selectLanguage: 'Sélectionner la langue',
		switchToLightMode: 'Passer en mode clair',
		switchToDarkMode: 'Passer en mode sombre',
		characters: 'lettres',
		alphabet: 'Alphabet',
		generatedValue: 'Valeur Générée',
		clickToSelect: 'Cliquez sur la zone de texte pour copier le contenu',
		waitGenerating: "Veuillez patienter pendant la génération d'une nouvelle valeur...",
		unknownEndpoint: 'Type de point de terminaison inconnu',
		failedToCopy: 'Échec de la copie',
		fallbackCopyFailed: 'Échec de la copie de secours',
		failedToRegenerate: 'Échec de la régénération',
		failedToLoadVersions: 'Échec du chargement des versions',
		mustBeBetween: 'doit être entre',
		and: 'et',
		cannotExceed: 'ne peut pas dépasser',
		optionalPrefix: 'Préfixe optionnel',
		optionalSuffix: 'Suffixe optionnel',
		prefixCannotExceed: 'Le préfixe ne peut pas dépasser 32 caractères',
		suffixCannotExceed: 'Le suffixe ne peut pas dépasser 32 caractères',
		yes: 'Oui',
		no: 'Non',
		cancel: 'Annuler',
		continue: 'Continuer',
		correct: 'Corriger',
		send: 'Envoyer',
		sending: 'Envoi en cours...',
		formInvalid: 'Formulaire invalide',
		connectionError: 'Erreur de connexion. Réessayez.',
		sendError: "Erreur lors de l'envoi du lien. Réessayez.",
		seedUsed: 'Graine Utilisée',
		copySeed: 'Copier Graine',
		optionalSeed: 'Graine optionnelle (64 caractères hex)',
		seedInvalid: 'La graine doit avoir exactement 64 caractères hexadécimaux',
		reuseSeedTitle: 'Réutiliser la même graine?',
		reuseSeedMessage:
			'Voulez-vous réutiliser la même graine pour générer le même résultat, ou préférez-vous générer une nouvelle graine aléatoire?',
		keepSameSeed: 'Garder la même graine',
		generateNewSeed: 'Générer une nouvelle graine',
		seed: 'Graine',
		otp: 'OTP',
		sessionExpired: 'Votre session a expiré.',
		close: 'Fermer',
		understand: 'Je comprends',
		// Error messages for user notifications
		magicLinkValidationFailed: 'Échec de la validation du lien magique',
		signatureValidationError: 'Réponse du serveur invalide reçue',
		parameterDecryptionFailed: 'Impossible de déchiffrer les paramètres',
		parameterDecryptionError: 'Erreur de déchiffrement des paramètres',
		generationError: 'Erreur de génération',
		regenerationError: 'Erreur de régénération',
		pageNotFound: 'Page non trouvée (404)',
		serverError: 'Erreur du serveur (500)',
		clientError: 'Erreur du client ({status})',
		genericError: 'Erreur ({status})',
		redirectingToHome: "Redirection vers l'accueil...",
		update: 'Mettre à jour',
		updating: 'Mise à jour',
		updateAvailable: 'Mise à jour disponible'
	},
	menu: {
		title: 'Générateur de Hash',
		subtitle: 'Choisissez une méthode de génération',
		version: 'Version',
		brandName: 'HashRand',
		description: 'Générateur cryptographiquement sécurisé de hashs, mots de passe et clés API'
	},
	custom: {
		title: 'Générateur de Hash Personnalisé',
		description: 'Générez des hashs aléatoires personnalisés',
		generateHash: 'Générer Hash',
		length: 'Longueur',
		alphabet: "Type d'Alphabet",
		prefix: 'Préfixe',
		suffix: 'Suffixe',
		lengthMustBeBetween: 'La longueur doit être entre 2 et 128',
		bitcoinDescription: 'Alphabet Bitcoin, exclut les lettres ambigues',
		maxReadabilityDescription: 'Lisibilité maximale, 49 lettres',
		completeAlphanumericDescription: 'Ensemble alphanumérique complet',
		maxEntropyDescription: 'Entropie maximale avec symboles',
		numericDescription: 'Chiffres 0-9 uniquement, nécessite une longueur plus importante',
		failedToGenerateHash: 'Échec de la génération du hash'
	},
	password: {
		title: 'Générateur de Mots de Passe Sécurisés',
		description: 'Générez des mots de passe sécurisés',
		generatePassword: 'Générer Mot de Passe',
		length: 'Longueur',
		alphabet: 'Jeu de Caractères',
		maxSecurityDescription: 'Sécurité maximale avec symboles (73 chars)',
		easyReadDescription: 'Facile à lire et taper (49 chars)',
		securityNote: 'Note de Sécurité :',
		securityDescription:
			'Les mots de passe sont générés en utilisant une génération aléatoire cryptographiquement sécurisée. Ils ne sont stockés ni journalisés nulle part.',
		noLookAlikeNote:
			"L'alphabet sans ambiguïté exclut les caractères confus. Minimum {0} caractères pour une sécurité équivalente.",
		fullAlphabetNote:
			"L'alphabet complet avec symboles fournit une entropie maximale. Minimum {0} caractères pour une sécurité forte.",
		failedToGeneratePassword: 'Échec de la génération du mot de passe'
	},
	apiKey: {
		title: 'Générateur de Clés API',
		description: 'Générez des clés API avec le préfixe ak_',
		generateApiKey: 'Générer Clé API',
		length: 'Longueur',
		alphabet: 'Jeu de Caractères',
		standardAlphanumericDescription: 'Alphanumérique standard (62 chars)',
		noConfusingDescription: 'Aucune lettre confuse (49 chars)',
		formatNotice:
			'Toutes les clés API sont générées avec le préfixe "ak_" pour une identification facile. La longueur spécifiée ne concerne que les caractères aléatoires générés (préfixe non compté).',
		securityNotice:
			'Stockez les clés API en sécurité et ne les exposez jamais dans le code côté client ou le contrôle de version. Traitez-les avec le même soin que les mots de passe.',
		formatPrefix: 'préfixe ak_ +',
		randomCharacters: 'caractères aléatoires avec',
		noLookAlikeAlphabet: 'alphabet sans ambiguïté (facile à taper)',
		fullAlphanumericAlphabet: 'alphabet alphanumérique complet',
		fullAlphanumericNote:
			"L'alphabet alphanumérique complet offre une compatibilité maximale. Minimum {0} caractères pour une sécurité forte.",
		failedToGenerateApiKey: 'Échec de la génération de la clé API'
	},
	mnemonic: {
		title: 'Générateur de Phrases Mnémotechniques BIP39',
		description:
			'Générez des phrases mnémotechniques BIP39 pour les portefeuilles de cryptomonnaies',
		generateMnemonic: 'Générer Phrase Mnémotechnique',
		language: 'Langue',
		wordCount: 'Nombre de Mots',
		languageDescription: 'Sélectionnez la langue pour votre phrase mnémotechnique',
		words12: '12 mots (entropie 128-bit)',
		words12Description: 'Entropie 128-bit - compatible avec la plupart des portefeuilles',
		words24: '24 mots (entropie 256-bit)',
		words24Description: 'Entropie 256-bit - sécurité maximale pour les grosses sommes',
		formatNotice:
			'Les phrases générées suivent le standard BIP39 et sont compatibles avec la plupart des portefeuilles de cryptomonnaies.',
		securityNotice:
			'Ne partagez jamais votre phrase mnémotechnique avec quiconque. Toute personne ayant accès à votre phrase mnémotechnique peut contrôler vos fonds. Gardez-la hors ligne dans un endroit sécurisé.',
		failedToGenerateMnemonic: 'Échec de la génération de la phrase mnémotechnique',
		languages: {
			english: 'Anglais',
			spanish: 'Espagnol',
			french: 'Français',
			portuguese: 'Portugais',
			japanese: 'Japonais',
			chinese: 'Chinois (Simplifié)',
			chineseTraditional: 'Chinois (Traditionnel)',
			italian: 'Italien',
			korean: 'Coréen',
			czech: 'Tchèque'
		}
	},
	alphabets: {
		base58: 'Base58 (alphabet Bitcoin)',
		'no-look-alike': 'Sans Ambiguïté',
		full: 'Alphanumérique Complet',
		'full-with-symbols': 'Complet avec Symboles',
		numeric: 'Numérique (0-9)'
	},
	auth: {
		loginRequired: 'Authentification Requise',
		loginDescription: "Entrez votre email pour recevoir un lien magique d'accès.",
		emailAddress: 'Adresse Email',
		emailPlaceholder: 'votre@email.com',
		emailRequired: "L'email est requis",
		emailInvalid: 'Veuillez entrer un email valide',
		sendMagicLink: 'Envoyer Lien Magique',
		requestFailed: 'Échec de la demande de lien magique',
		confirmEmail: 'Confirmer Email',
		confirmEmailDescription: 'Est-ce correct?',
		magicLinkSent: 'Lien Envoyé!',
		magicLinkInstructions:
			'Vérifiez votre email et cliquez sur le lien magique pour vous authentifier.',
		magicLinkSentFlash:
			'Lien magique envoyé. Vérifiez votre email et cliquez sur le lien pour continuer.',
		magicLinkErrorFlash: "Erreur lors de l'envoi du lien magique. Veuillez réessayer.",
		developmentMode: 'Mode Développement:',
		testMagicLink: 'Cliquer ici pour tester le lien magique',
		authenticationFailed: "Échec de l'authentification",
		tokenExpired: 'Votre session a expiré. Veuillez vous reconnecter.',
		accessDenied: 'Accès refusé. Authentification requise.',
		sessionDataCleared: '⚠️ Données de session effacées par sécurité',
		userMenu: 'Menu utilisateur',
		login: 'Se connecter',
		authenticatedAs: 'Connecté en tant que :',
		logout: 'Se déconnecter',
		logoutConfirmTitle: 'Se Déconnecter',
		logoutConfirmMessage:
			'Êtes-vous sûr de vouloir vous déconnecter? Vous devrez vous authentifier à nouveau pour accéder aux fonctionnalités protégées.',
		loggedOut: 'Déconnexion réussie',
		isCorrect: "C'est correct",
		magicLinkError: {
			title: 'Erreur de Lien Magique',
			message: 'Ce lien magique ne peut être utilisé que dans le navigateur original',
			explanation:
				'Pour des raisons de sécurité, les liens magiques doivent être ouverts dans le même navigateur où ils ont été demandés.',
			securityTitle: 'Pourquoi cette mesure de sécurité ?',
			securityExplanation:
				"Cette validation à double facteur garantit que seule la personne qui a demandé le lien magique depuis ce navigateur spécifique peut l'utiliser."
		},
		// NOUVEAU : Messages de sécurité et de secours
		magicLinkValidatedSuccess: '✅ Lien magique validé avec succès !',
		tokenRefreshStarting: '🔄 Démarrage du renouvellement du jeton...',
		newKeypairGenerated: '🔑 Nouvelle paire de clés générée pour la rotation',
		sendingRefreshRequest: '📤 Envoi de la requête à /api/refresh...',
		refreshResponseReceived: '📥 Réponse reçue du serveur',
		keyRotationStarting: '🔄 ÉTAPE 2/3 : Démarrage de la rotation des clés...',
		keyRotationCompleted: '✅ Rotation des clés terminée (2/3)',
		tokenRenewedNoRotation: '⏭️ Jeton renouvelé sans rotation (1/3)',
		tokenRefreshSuccess: '✅ Jeton renouvelé avec succès',
		tokenRefreshError: '❌ Erreur lors du renouvellement du jeton',
		sessionExpiredRequireLogin: '⚠️ Session expirée - nouvelle connexion requise',
		cryptoTokensMissing: '🔐 Jetons cryptographiques manquants - authentification requise',
		sessionCorrupted: '⚠️ Session corrompue - veuillez vous reconnecter',
		storageSaveFailed:
			'⚠️ La session pourrait ne pas persister entre les rechargements de page (problème de stockage)',
		encryptionFailed: "⚠️ Impossible de chiffrer les paramètres - redirection vers l'accueil",
		requiresAuthentication: '🔐 Authentification requise pour continuer'
	},
	sharedSecret: {
		title: 'Secret Partagé',
		description: 'Partagez des messages sécurisés avec expiration automatique',
		senderEmail: 'Votre email',
		emailNotAvailable: 'Email non disponible - Veuillez vous connecter',
		receiverEmail: 'Email du destinataire',
		receiverEmailPlaceholder: 'destinataire@exemple.fr',
		secretText: 'Message secret',
		secretTextPlaceholder: 'Entrez votre message sécurisé (maximum 512 caractères)',
		expiresHours: 'Expire dans (heures)',
		maxReads: 'Lectures maximales',
		requireOtp: 'Exiger un OTP à 9 chiffres',
		sendCopyToSender: "M'envoyer une copie par email",
		createSecret: 'Créer un Secret Partagé',
		creating: 'Création...',
		secretCreated: 'Secret partagé créé avec succès',
		yourUrl: 'Votre URL (lectures illimitées)',
		receiverUrl: 'URL du destinataire (lectures limitées)',
		reference: 'Référence',
		otpCode: 'Code OTP',
		copyUrl: "Copier l'URL",
		copyReference: 'Copier la Référence',
		copyOtp: "Copier l'OTP",
		viewSecret: 'Voir le Secret',
		enterOtp: "Entrez l'OTP à 9 chiffres",
		otpPlaceholder: '123456789',
		submit: 'Envoyer',
		submitting: 'Validation...',
		secretContent: 'Contenu du Secret',
		from: 'De',
		to: 'À',
		pendingReads: 'Lectures restantes',
		unlimited: 'Illimitées',
		expiresAt: 'Expire le',
		role: 'Votre rôle',
		roleSender: 'Expéditeur',
		roleReceiver: 'Destinataire',
		deleteSecret: 'Supprimer le Secret',
		deleting: 'Suppression...',
		secretDeleted: 'Secret supprimé avec succès',
		confirmDelete: 'Êtes-vous sûr de vouloir supprimer ce secret?',
		otpRequired: 'Ce secret nécessite un OTP pour y accéder',
		invalidOtp: 'OTP invalide',
		invalidHash: 'Identifiant de secret invalide ou manquant',
		secretNotFound: 'Secret introuvable ou expiré',
		secretExpired: 'Le secret a expiré ou toutes les lectures ont été consommées',
		emailInvalid: 'Adresse email invalide',
		secretTooLong: 'Le texte du secret ne peut pas dépasser 512 caractères',
		secretEmpty: 'Le texte du secret ne peut pas être vide',
		expiresInvalid: "L'expiration doit être entre 1 et 72 heures",
		readsInvalid: 'Les lectures maximales doivent être entre 1 et 10',
		creationError: 'Erreur lors de la création du secret',
		retrievalError: 'Erreur lors de la récupération du secret',
		accessDenied: 'Accès refusé : Ce secret appartient à un autre utilisateur',
		deletionError: 'Erreur lors de la suppression du secret',
		// M3: Enhanced metadata
		unlimitedHint: 'As the sender, you can view this secret unlimited times',
		consumed: 'Consumed',
		consumedHint: 'All reads have been used',
		readRemaining: 'read remaining',
		readsRemaining: 'reads remaining',
		lastReadHint: '⚠️ This is your last available read. The secret will self-destruct after.',
		multipleReadsHint: 'You can access this secret multiple more times',
		timeRemaining: 'Time remaining',
		expired: 'Expired',
		// M1: Last read warning banner
		lastReadWarningTitle: '⚠️ Last Read Available',
		lastReadWarningMessage:
			'This is your last access to this secret. Once you close or reload this page, the secret will be permanently auto-deleted.',
		lastReadWarningTip: 'Save the information now if you need to keep it.',
		// M4: Pre-submit confirmation
		confirmLastRead:
			'⚠️ This will consume your last available read. The secret will auto-delete after.\n\nAre you sure you want to continue?',
		confirmReadConsumption: 'Reading this secret will consume 1 read.',
		readsRemainingAfter: 'You will have',
		accessError: "Impossible d'accéder au secret partagé"
	},
	logout: {
		title: 'Se Déconnecter',
		description: 'Êtes-vous sûr de vouloir vous déconnecter?',
		confirm: 'Se Déconnecter',
		cancel: 'Annuler',
		info: "Vous perdrez l'accès aux fonctionnalités authentifiées jusqu'à ce que vous vous reconnectiez.",
		tokenExpired: 'Votre session a expiré. Veuillez vous reconnecter.',
		accessDenied: 'Accès refusé. Authentification requise.',
		userMenu: 'Menu utilisateur',
		login: 'Se connecter',
		authenticating: 'Authenticating...',
		authenticatedAs: 'Connecté en tant que :',
		logout: 'Se déconnecter',
		confirmLogout: 'Se déconnecter?',
		logoutDescription:
			'Êtes-vous sûr de vouloir vous déconnecter? Vous devrez vous authentifier à nouveau pour accéder aux fonctionnalités protégées.',
		// NOUVEAU : Messages flash de déconnexion
		successMessage: '✅ Déconnexion réussie',
		errorMessage: '❌ Erreur lors de la déconnexion'
	},
	errors: {
		// NOUVEAU : Messages de la page d'erreur
		pageNotFoundMessage: "Page introuvable (404). Redirection vers l'accueil...",
		serverErrorMessage: "Erreur du serveur (500). Redirection vers l'accueil...",
		clientErrorMessage: "Erreur du client ({status}). Redirection vers l'accueil...",
		genericErrorMessage: "Erreur ({status}). Redirection vers l'accueil..."
	}
};
